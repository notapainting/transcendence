TODO: 
	-check for no async ORM in API 


FIXME: 
	- POST on /users without '/' -> 500
    - POST without body



./manage.py makemigrations
./manage.py shell


database:
	user:
		-username (id)
		-contact (multikey)
		-blocked (multikey)
		-conv ? (= user + blocked)

	messages :
		-conv
		-author
		-date 
		-body


u: bob
	-c: marie, jon
	-b: marc
	-


API
user -> user data
	 -> contact
	 -> blocked
	 -> conv	-> APIconv
	 -> message	-> APImessage

conv -> conv
	 -> participants	-> list ->  APIuser
	 -> message 		-> list -> APImessage

message	-> message data (body. date. author id)
		-> author	-> APIuser
		-> conv		-> APIconv

APIv1 : /api/v1/

USER: /users/ 
'' 
	-> GET -> list of users

':id/'	-> id is a uuid
	-> POST -> create user <id> with payload, payload only accept 'name' field
from now ':id/' in USER can be a name
		-> GET -> user <id> data
		-> PUT -> change user <id> data from payload, payload only accept 'name' field
		-> DELETE -> delete user <id>

':id/contacts/'
	-> POST


https://stackoverflow.com/questions/30752268/how-to-filter-objects-for-count-annotation-in-django





user 2 connect: -> groups username

cl	->	msg	->	cs 
		| from 
		| to : conv (groups?) (!doublon)



Tuc: Two users conv
Muc: Multiple users conv
Ssu: Single session user
Msu: Multiple sessions user


conv-groups arch: (G = O(n), n is number of conv)
	Ssu: session add to group on connect
	Msu: each session add to group on connect
	
	1 conv (Tuc/Muc) = 1 group

db store
-> list of conv : unique group_name
-> 



user-groups arch : (G = O(u), u is number of user)
	1 user (Ssu/Msu) = 1 group


	Tuc : user A send to user-group B, B respond with 'author' field to user-group A
	Muc : user A send to user-group B, then user-group C,...etc , users can respond with 'chat.group' field 



websocket auth : 
(see https://devcenter.heroku.com/articles/websocket-security)
	- pass JWT in query string (see code in java)
	- auth extern 
	- Smuggle access tokens inside Sec-WebSocket-Protocol

Since the only header a browser will let you control is Sec-WebSocket-Protocol, 
you can abuse it to emulate any other header. Interestingly (or rather comically),
 this is what Kubernetes is doing. In short, you append whatever you need for 
 authentication as an extra supported subprotocol inside Sec-WebSocket-Protocol:

var ws = new WebSocket("ws://example.com/path", ["realProtocol", "yourAccessTokenOrSimilar"]);

Then, on the server, you add some sort of middleware that transforms the request 
back to its saner form before passing it further into the system. Terrible, yes, 
but so far the best solution. No tokens in the URL, no custom authentication save 
for the little middleware, no extra state on the server needed. 
 Do not forget to include the real subprotocol, as various tools will 
 reject a connection without one.

dont:
	- via cookie (very unsecure with ws)

https://asgi.readthedocs.io/en/latest/specs/www.html#websocket

TODO:2
	- read activitypub
	- simple chat with 2 user
		- front basic
		- back
	- dummy auth via ws:// ?username
	- add chat history 
	- make chat private
	- make contact list
	- 


aUTH ?
store old username for sometime
vm : install vscode extension directement


e30bdce1-efd2-46da-ae86-ccee2df6e21b



arch server/app:
	-chat app server 
		- chat
		- notification
		- see/writing/online...
		- profile
		- contact list managment
		-
	-bot
	- pictures/file
		-sticker bank
		-file transfert server 
		-pictures integration
		-theme bank ?
		-gif

	

user : 
08c5e0ae-69b8-418e-84c5-9010ef8d1d1e	luciole

dc9eafa7-e01b-42c6-90b9-766987b6e2ba	acheron

32d52fba-fe52-4129-9aee-eb252de9d2f1	sam


OBJ:
	-auth via auth api
	-chat prive
	-chat multi-session 
	-chat group
	-contact list
	-block/restrain user 
	-user creation in chat db
	-game invitation
	-notification 
	-response to message
	-profile link


BONUS:
	-links preview/alert when quit
	-end-to-end ecnrypt
	-bot
	-image integration
	-stickers bank
	-tone indicator https://toneindicators.carrd.co/
	-file transfert
	-conv theme ? 
	- db cluster ?
	- access control : user roles and permissions, or IP-based access restrictions



